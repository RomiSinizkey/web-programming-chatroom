<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf-8" />
    <title>Chatroom</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
            rel="stylesheet"
    >
    <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />

    <style>
        #messagesBox {
            height: 420px;
            overflow-y: auto;
            background: #fff;
        }
        .msg-meta {
            font-size: 0.8rem;
            color: #6c757d;
        }
        .msg-bubble {
            white-space: pre-wrap;
            word-break: break-word;
        }

        mark.chat-highlight {
            padding: 0 2px;
            border-radius: 3px;
        }
        mark.chat-highlight.current {
            outline: 2px solid rgba(0,0,0,0.2);
        }
    </style>
</head>

<body class="bg-light">
<div class="container py-5">
    <div class="row justify-content-center">
        <div class="col-12 col-md-10 col-lg-8">

            <div class="d-flex justify-content-between align-items-center mb-3">
                <h1 class="h4 mb-0">Chatroom</h1>
                <a href="/logout" class="btn btn-outline-secondary btn-sm">Logout</a>
            </div>

            <div class="alert alert-success" role="alert">
                Logged in as <strong><%= user.firstName %> <%= user.lastName %></strong>
                (<%= user.email %>)
            </div>

            <div class="card shadow-sm">
                <div class="card-body">

                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <div class="text-muted small">Messages (latest 50)</div>

                        <div class="d-flex gap-2">
                            <button id="selectAllBtn" type="button" class="btn btn-sm btn-outline-secondary">Select all</button>
                            <button id="clearAllBtn" type="button" class="btn btn-sm btn-outline-secondary">Clear</button>
                            <button id="deleteSelectedBtn" type="button" class="btn btn-sm btn-outline-danger" disabled>
                                Delete selected
                            </button>
                            <button id="refreshBtn" type="button" class="btn btn-sm btn-outline-primary">Refresh</button>
                        </div>
                    </div>

                    <div class="d-flex gap-2 align-items-center mb-2">
                        <input id="searchInput" class="form-control form-control-sm"
                               type="text" placeholder="Search messages..."
                               autocomplete="off" />

                        <button id="prevMatchBtn" type="button" class="btn btn-sm btn-outline-secondary" disabled>
                            Prev
                        </button>
                        <button id="nextMatchBtn" type="button" class="btn btn-sm btn-outline-secondary" disabled>
                            Next
                        </button>

                        <div id="matchInfo" class="text-muted small ms-1"></div>
                    </div>

                    <div id="messagesBox" class="border rounded p-3 mb-3"></div>

                    <form id="sendForm" class="d-flex gap-2" autocomplete="off" method="POST" action="/messages">
                        <label for="msgInput" class="visually-hidden">Message</label>
                        <input
                                id="msgInput"
                                name="text"
                                type="text"
                                class="form-control"
                                maxlength="500"
                                placeholder="Type a message..."
                                required
                        />

                        <button id="sendBtn" class="btn btn-primary" type="submit">Send</button>
                    </form>

                    <div id="errorBox" class="mt-3 d-none alert alert-danger mb-0"></div>

                </div>
            </div>

        </div>
    </div>
</div>

<script>
    const currentUserEmail = "<%= user.email %>";

    const messagesBox = document.getElementById("messagesBox");
    const errorBox = document.getElementById("errorBox");
    const msgInput = document.getElementById("msgInput");
    const refreshBtn = document.getElementById("refreshBtn");
    const selectAllBtn = document.getElementById("selectAllBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");
    const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");

    const searchInput = document.getElementById("searchInput");
    const prevMatchBtn = document.getElementById("prevMatchBtn");
    const nextMatchBtn = document.getElementById("nextMatchBtn");
    const matchInfo = document.getElementById("matchInfo");

    // messages state
    let allMessages = [];
    let filteredMessages = [];
    let matchIds = [];
    let currentMatchIndex = -1;

    // selection state (for multi delete)
    const selectedIds = new Set();

    // render optimization
    let lastRenderedHash = "";

    function showError(msg) {
        if (!errorBox) return;
        errorBox.textContent = msg;
        errorBox.classList.remove("d-none");
    }

    function clearError() {
        if (!errorBox) return;
        errorBox.textContent = "";
        errorBox.classList.add("d-none");
    }

    function updateDeleteSelectedUI() {
        if (!deleteSelectedBtn) return;
        deleteSelectedBtn.disabled = selectedIds.size === 0;
        deleteSelectedBtn.textContent = selectedIds.size === 0
            ? "Delete selected"
            : `Delete selected (${selectedIds.size})`;
    }

    async function deleteSelected() {
        if (selectedIds.size === 0) return;
        if (!confirm(`Delete ${selectedIds.size} selected messages?`)) return;

        clearError();

        const ids = Array.from(selectedIds);

        const res = await fetch("/api/messages/delete-many", {
            method: "POST",
            headers: { "Content-Type": "application/json", "Accept": "application/json" },
            body: JSON.stringify({ ids }),
        });

        if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            showError(body.error || `Failed to delete messages (${res.status})`);
            return;
        }

        selectedIds.clear();
        updateDeleteSelectedUI();
        await loadMessages();
    }

    function escapeHtml(str) {
        return String(str)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }

    function escapeRegex(s) {
        return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function highlightText(text, query) {
        const safe = escapeHtml(text || "");
        const q = (query || "").trim();
        if (!q) return safe;

        const re = new RegExp(escapeRegex(q), "gi");
        return safe.replace(re, (m) => `<mark class="chat-highlight">${m}</mark>`);
    }

    function formatTime(iso) {
        if (!iso) return "";
        const d = new Date(iso);
        return Number.isNaN(d.getTime()) ? "" : d.toLocaleString();
    }

    function hashMessages(arr) {
        // include search text too? not necessary, but we hash message changes
        return JSON.stringify(arr.map(m => [m.id, m.updatedAt, m.deletedAt]));
    }

    function applySearchAndRender() {
        const q = (searchInput?.value || "").trim().toLowerCase();

        filteredMessages = !q
            ? allMessages
            : allMessages.filter(m => String(m.text || "").toLowerCase().includes(q));

        matchIds = filteredMessages.map(m => String(m.id));
        currentMatchIndex = matchIds.length ? 0 : -1;

        if (prevMatchBtn) prevMatchBtn.disabled = matchIds.length === 0;
        if (nextMatchBtn) nextMatchBtn.disabled = matchIds.length === 0;

        if (matchInfo) {
            matchInfo.textContent = matchIds.length
                ? `1 / ${matchIds.length}`
                : (q ? "0 matches" : "");
        }

        // Important: render filtered list
        renderMessages(filteredMessages);

        // and highlight current match
        highlightCurrentMatchInDom();
    }

    function highlightCurrentMatchInDom() {
        if (currentMatchIndex < 0 || !matchIds.length) return;

        document.querySelectorAll("mark.chat-highlight.current")
            .forEach(el => el.classList.remove("current"));

        const targetId = matchIds[currentMatchIndex];

        const wrapper = messagesBox.querySelector(`[data-msg-id="${CSS.escape(targetId)}"]`);
        if (!wrapper) return;

        const firstMark = wrapper.querySelector("mark.chat-highlight");
        if (firstMark) firstMark.classList.add("current");

        wrapper.scrollIntoView({ behavior: "smooth", block: "center" });
    }

    function renderMessages(messages) {
        if (!messagesBox) return;

        const h = hashMessages(messages);
        if (h === lastRenderedHash) return;
        lastRenderedHash = h;

        messagesBox.innerHTML = "";

        if (!messages.length) {
            messagesBox.innerHTML = '<div class="text-muted">No messages yet.</div>';
            return;
        }

        const q = (searchInput?.value || "").trim();

        for (const m of messages) {
            const email = (m.userEmail || "").toLowerCase();
            const isMine = email === String(currentUserEmail).toLowerCase();

            const wrapper = document.createElement("div");
            wrapper.className = "mb-3";
            wrapper.dataset.msgId = String(m.id);

            const meta = document.createElement("div");
            meta.className = "msg-meta";
            const firstName = m.User?.firstName || "Unknown";
            meta.textContent = `${firstName} • ${formatTime(m.createdAt)}`;

            const bubble = document.createElement("div");
            bubble.className = "msg-bubble border rounded p-2 " + (isMine ? "bg-primary text-white" : "bg-light");

            const textDiv = document.createElement("div");
            textDiv.innerHTML = highlightText(m.text || "", q);
            bubble.appendChild(textDiv);

            wrapper.appendChild(meta);
            wrapper.appendChild(bubble);

            if (isMine) {
                const actions = document.createElement("div");
                actions.className = "mt-2 d-flex gap-2 align-items-center";

                // ✅ MULTI-SELECT checkbox
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.className = "form-check-input mt-0";
                cb.title = "Select";

                const idStr = String(m.id);
                cb.value = idStr;
                cb.dataset.msgId = idStr;
                cb.checked = selectedIds.has(idStr);

                cb.addEventListener("change", () => {
                    if (cb.checked) selectedIds.add(idStr);
                    else selectedIds.delete(idStr);
                    updateDeleteSelectedUI();
                });

                actions.appendChild(cb);

                // DELETE (single)
                const deleteForm = document.createElement("form");
                deleteForm.method = "POST";
                deleteForm.action = "/messages/delete";

                const hiddenId1 = document.createElement("input");
                hiddenId1.type = "hidden";
                hiddenId1.name = "id";
                hiddenId1.value = String(m.id);

                const trashBtn = document.createElement("button");
                trashBtn.type = "submit";
                trashBtn.className = "btn btn-sm btn-outline-danger";
                trashBtn.title = "Delete";
                trashBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';

                deleteForm.appendChild(hiddenId1);
                deleteForm.appendChild(trashBtn);

                // EDIT (fetch)
                const editBtn = document.createElement("button");
                editBtn.type = "button";
                editBtn.className  = "btn btn-sm btn-outline-secondary";
                editBtn.title = "Edit";
                editBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';

                editBtn.addEventListener("click", () => {
                    if (bubble.dataset.editing === "1") return;
                    bubble.dataset.editing = "1";

                    const originalText = m.text || "";

                    const input = document.createElement("input");
                    input.type = "text";
                    input.maxLength = 500;
                    input.className = "form-control form-control-sm";
                    input.value = originalText;

                    const saveBtn = document.createElement("button");
                    saveBtn.type = "button";
                    saveBtn.className = "btn btn-sm btn-success";
                    saveBtn.innerHTML = '<i class="fa-solid fa-check"></i>';

                    const cancelBtn = document.createElement("button");
                    cancelBtn.type = "button";
                    cancelBtn.className = "btn btn-sm btn-outline-secondary";
                    cancelBtn.innerHTML = '<i class="fa-solid fa-xmark"></i>';

                    const editRow = document.createElement("div");
                    editRow.className = "d-flex gap-2 align-items-center";
                    editRow.appendChild(input);
                    editRow.appendChild(saveBtn);
                    editRow.appendChild(cancelBtn);

                    textDiv.innerHTML = "";
                    textDiv.appendChild(editRow);
                    input.focus();

                    async function save() {
                        const trimmed = input.value.trim();
                        if (!trimmed) return;

                        clearError();

                        const res = await fetch(`/api/messages/${m.id}`, {
                            method: "PATCH",
                            headers: { "Content-Type": "application/json", "Accept": "application/json" },
                            body: JSON.stringify({ text: trimmed }),
                        });

                        if (!res.ok) {
                            const body = await res.json().catch(() => ({}));
                            showError(body.error || `Failed to edit message (${res.status})`);
                            return;
                        }

                        bubble.dataset.editing = "0";
                        await loadMessages();
                    }

                    function cancel() {
                        bubble.dataset.editing = "0";
                        textDiv.innerHTML = highlightText(originalText, q);
                        highlightCurrentMatchInDom();
                    }

                    saveBtn.addEventListener("click", () => void save());
                    cancelBtn.addEventListener("click", cancel);

                    input.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") void save();
                        if (e.key === "Escape") cancel();
                    });
                });

                actions.appendChild(deleteForm);
                actions.appendChild(editBtn);
                wrapper.appendChild(actions);
            }

            messagesBox.appendChild(wrapper);
        }

        messagesBox.scrollTop = messagesBox.scrollHeight;
    }

    async function loadMessages() {
        clearError();

        const res = await fetch("/api/messages", { headers: { "Accept": "application/json" } });
        if (!res.ok) {
            const body = await res.json().catch(() => ({}));
            showError(body.error || `Failed to load messages (${res.status})`);
            return;
        }

        const messages = await res.json();
        allMessages = messages;

        // use search state
        applySearchAndRender();
    }

    // Events
    if (refreshBtn) refreshBtn.addEventListener("click", () => void loadMessages());

    if (selectAllBtn) {
        selectAllBtn.addEventListener("click", () => {
            // select only visible (filtered) messages that are mine
            selectedIds.clear();

            for (const m of filteredMessages) {
                if (String(m.userEmail).toLowerCase() === String(currentUserEmail).toLowerCase()) {
                    selectedIds.add(String(m.id));
                }
            }

            document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                const id = cb.value;
                cb.checked = selectedIds.has(id);
            });

            updateDeleteSelectedUI();
        });
    }

    if (clearAllBtn) {
        clearAllBtn.addEventListener("click", () => {
            selectedIds.clear();

            document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });

            updateDeleteSelectedUI();
        });
    }

    if (deleteSelectedBtn) {
        deleteSelectedBtn.addEventListener("click", () => void deleteSelected());
    }

    if (searchInput) {
        searchInput.addEventListener("input", () => {
            applySearchAndRender();
        });

        searchInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && matchIds.length) {
                e.preventDefault();
                currentMatchIndex = (currentMatchIndex + 1) % matchIds.length;
                if (matchInfo) matchInfo.textContent = `${currentMatchIndex + 1} / ${matchIds.length}`;
                highlightCurrentMatchInDom();
            }
        });
    }

    if (nextMatchBtn) {
        nextMatchBtn.addEventListener("click", () => {
            if (!matchIds.length) return;
            currentMatchIndex = (currentMatchIndex + 1) % matchIds.length;
            if (matchInfo) matchInfo.textContent = `${currentMatchIndex + 1} / ${matchIds.length}`;
            highlightCurrentMatchInDom();
        });
    }

    if (prevMatchBtn) {
        prevMatchBtn.addEventListener("click", () => {
            if (!matchIds.length) return;
            currentMatchIndex = (currentMatchIndex - 1 + matchIds.length) % matchIds.length;
            if (matchInfo) matchInfo.textContent = `${currentMatchIndex + 1} / ${matchIds.length}`;
            highlightCurrentMatchInDom();
        });
    }

    // Init + polling
    const POLLING = 10_000; // 10 seconds
    void loadMessages();
    setInterval(() => void loadMessages(), POLLING);
</script>

</body>
</html>
